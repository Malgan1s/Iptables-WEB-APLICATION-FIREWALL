# Iptables-WEB-APLICATION-FIREWALL

**Цель**: Изучение межсетевых экранов. Приобретение навыков работы с Iptables и WAF.

# **1 Основные теоретические сведения**

## **1.1 Межсетевой экран**

В ядро Linux встроен свой межсетевой экран, называемый Netfilter. Управление им осуществляется с помощью утилиты Iptables.

Межсетевой экран, сетевой экран, файервол, брандмауэр — комплекс аппаратных или программных средств, осуществляющий контроль и фильтрацию проходящих через него сетевых пакетов в соответствии с заданными правилами. Основной задачей сетевого экрана является защита компьютерных сетей или отдельных узлов от несанкционированного доступа. Также сетевые экраны часто называют фильтрами, так как их основная задача — не пропускать (фильтровать) пакеты, не подходящие под критерии, определённые в конфигурации.

Рассмотрим принцип работы Netfilter. Когда сетевые пакеты попадают в сетевой интерфейс, они после ряда проверок ядром проходят последовательность так называемых цепочек. Пакет обязательно проходит через цепочку PREROUTING, после чего определяется, кому он, собственно, был адресован. Если пакет не адресован локальной системе (в нашем случае серверу), он попадает в цепочка FORWARD, а иначе — в цепочку INPUT, после прохождения которой отдается локальным демонам или процессам. После этого при необходимости формируется ответ, который направляется в цепочку OUTPUT. После цепочек OUTPUT или FORWARD пакет в очередной раз встречается с правилами маршрутизации и направляется в цепочку POSTROUTING. В результате прохождения пакетом цепочек фильтрации несколько раз, проверка его принадлежности определенным критериям осуществляется несколько раз. В соответствии с этими проверками к пакету применяется определенное действие:

● ACCEPT — пакет «принимается» и передается в следующую цепочку.

● DROP — удовлетворяющий условию пакет отбрасывается и не передается в другие таблицы или цепочки.

● REJECT — пакет отбрасывается, но при этом отправителю отправляется ICMP-сообщение, сообщающее об отказе.

● RETURN — пакет возвращается в предыдущую цепочку и продолжает её прохождение начиная со следующего правила

● SNAT — применить трансляцию источника в пакете. Используется только в цепочках POSTROUTING и OUTPUT таблицы nat.

● DNAT — применить трансляцию адреса назначения в пакете. Используется в цепочках PREROUTING и (очень редко) OUTPUT в таблице nat.

## **1.2 Основные цепочки межсетевого экрана Netfilter:**

● PREROUTING — изначальная обработка входящих пакетов

● INPUT — для входящих пакетов, адресованных непосредственно локальному компьютеру

● FORWARD — для маршрутизируемых пакетов

● OUTPUT — для пакетов, исходящих с локального компьютера

● POSTROUTING — для окончательной обработки исходящих пакетов

## **1.3 Таблицы межсетевого экрана Netfilter:**

● raw - используется для маркировки пакетов, которые не должны обрабатываться системой определения состояний. Содержится в цепочках PREROUTING и OUTPUT.

● mangle — содержит правила модификации IP-пакетов.

● nat - предназначена для подмены адреса отправителя или получателя. Данную таблицу проходят только первые пакеты из потока - трансляция адресов или маскировка (подмена адреса отправителя или получателя) применяются ко всем последующим пакетам в потоке автоматически. Поддерживает действия DNAT, SNAT, MASQUERADE, REDIRECT. Содержится в цепочках PREROUTING, OUTPUT, и POSTROUTING.

● filter — основная таблица, используется по умолчанию если название таблицы не указано. Используется для фильтрации пакетов. Содержится в цепочках INPUT, FORWARD, и OUTPUT.

## **1.4 Пример создания правила для межсетевого экрана:**

Рассмотрим две цепочки, задающие два основных правила Iptables — PREROUTING и FORWARD.

● iptables -t nat -A PREROUTING -i eth0 -j DNAT —to-destination 192.168.57.102

● iptables -A FORWARD -d 192.168.57.102 -j ACCEPT

Первая из них определяет первоначальную обработку всех пакетов, приходящих на адаптер eth0:

● -t определяет подключаемую таблицу, в данном случае — nat — для подмены адреса отправителя или получателя

● -А — выбор цепочки

● -i — входящий интерфейс

● -j — действие с пакетами, удовлетворяющими условию — в данном случае DNAT — подмена адреса получателя

● –to-destination — выбор адреса, на который перенаправляются пакеты

● Вторая определяет проброс пакетов через сервер:

● -A — выбор цепочки

● -d — выбор адресата

● -j — выбор действия

## **1.5 Web Application Firewall**

WAF (Web Application Firewall) - это межсетевые экраны, работающие на прикладном уровне и осуществляющие фильтрацию трафика Web-приложений. Эти средства не требуют изменений в исходном коде Web-приложения и, как правило, защищают Web-сервисы гораздо лучше обычных межсетевых экранов и средств обнаружения вторжений.

**Основные преимущества:**

● Анализ поведения пользователя в используемом приложении;

● Позволяет осуществлять мониторинг HTTP трафика и проводить анализ событий в реальном режиме времени;

● Предотвращение вредоносных запросов;

● Распознавание большинства опасных угроз;

● Дополнение сетевых средств безопасности;

● Просматривать детальные отчеты об атаках и попытках взлома.

# 2 Практическая часть

## Часть 1. Iptables.

1. Создаём 2 виртуальные машины Linux:

![Описание изображения](/images/image7.png)

2. Настраиваем сетевые адаптеры данных машин для работы в режиме NAT. Для этого возьмём значение изолированной сети “Nat” из прошлой лабораторной работы. Затем выбираем тип подключения «Сеть NAT» на обеих машинах:

![Описание изображения](/images/image8.png)

3. Запускаем машины. Пусть первая машина “vm1” будет Атакующей, “vm2” – Атакуемой. Теперь определяем IP и MAC адреса виртуальных машин используя команду “ip a”.

Первая машинa – Атакующий (X). IP адрес – 192.168.10.8/27, MAC адрес – 08:00:27:f6:26:d0.

![Описание изображения](/images/image9.png)

Вторая машина – Атакуемый (N). IP адрес – 192.168.10.9/27, MAC адрес – 08:00:27:bf:76:1f.

![Описание изображения](/images/image10.png)

4. Далее на атакующую машину необходимо установить дополнительные пакеты. Выполним в терминале следующие команды:
“sudo apt-get update”
“sudo apt-get install curl”

![Описание изображения](/images/image11.png)
![Описание изображения](/images/image12.png)

5. Далее на атакуемой машине необходимо установить дополнительные пакеты. Выполним в терминале следующие команды:

* “sudo apt-get update” 

![Описание изображения](/images/image13.png)

* “sudo apt-get install apache2” (устанавливаем веб-сервер)

![Описание изображения](/images/image14.png)

* “sudo apt-get install libapache2-mod-security2” (устанавливаем модуль детектирования атак)

![Описание изображения](/images/image15.png)

* “sudo apachectl -M | grep --color security2”

![Описание изображения](/images/image16.png)

Видим, что на экране появился модуль по имени “security2_module (shared)”, значит, все прошло успешно.

6. Далее проводим утилитой nmap Xmas сканирование атакуемой машины на порту 80. Воспользуемся командой “sudo nmap -sX -p 80 192.168.10.9”:

![Описание изображения](/images/image17.png)

7. Далее настроим защиту атакуемой машины:

* Просмотрим список текущих правил iptables таблицы filter, используя команду “sudo iptables -L”

![Описание изображения](/images/image18.png)

* Видим, что список содержит три цепочки по умолчанию (INPUT, OUTPUT и FORWARD), в каждой из которых установлена политика по умолчанию (на данный момент это ACCEPT).

* С помощью команды “sudo iptables -S” данный список можно просмотреть в другом формате, который отражает команды, необходимые для активации правил и политик.

![Описание изображения](/images/image19.png)

* Чтобы сбросить текущие правила (если таковые есть), используем команду “sudo iptables -F”.

![Описание изображения](/images/image20.png)

Цепочка INPUT отвечает за входящий траффик

* Чтобы внести локальный интерфейс в разрешенные выполним команду “sudo iptables -A INPUT -i lo -j ACCEPT”.

![Описание изображения](/images/image21.png)

* Чтобы заблокировать весь исходящий трафик, кроме портов для SSH и веб-сервера, нужно сначала разрешить подключения к этим портам. В цепочку ACCEPT добавляем два порта (порт SSH 22 и порт http 80), что разрешит трафик на эти порты:

“sudo iptables -A INPUT -p tcp -m tcp –dport 22 -j ACCEPT”
“sudo iptables -A INPUT -p tcp -m tcp –dport 80 -j ACCEPT”

![Описание изображения](/images/image22.png)

* В данной работе мы не используем SSH. Так что удалим ненужное правило. Для этого выполним команду “sudo iptables -D INPUT -p tcp -m tcp –dport 22 -j ACCEPT”.

![Описание изображения](/images/image23.png)

* Нужно добавить еще одно правило, которое позволит устанавливать исходящие соединения (т. е. использовать “ping” или запускать обновления программного обеспечения). Для этого введём:

“sudo iptables -I INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT”

![Описание изображения](/images/image24.png)

* Создав все эти правила, можно заблокировать все остальное и разрешить все исходящие соединения.

“sudo iptables -P OUTPUT ACCEPT”
“sudo iptables -P INPUT DROP”

![Описание изображения](/images/image25.png)

* Просмотрим список правил, используя команду “sudo iptables -L”

![Описание изображения](/images/image26.png)

* Добавим еще несколько правил для блокировки наиболее распространенных атак. Для начала нужно заблокировать нулевые пакеты:

“sudo iptables -A INPUT -p tcp –tcp-flags ALL NONE -j DROP”

![Описание изображения](/images/image27.png)

* Следующее правило отражает атаки syn-пакетами без состояния NEW:

“sudo iptables -A INPUT -p tcp ! –syn -m state –state NEW -j DROP”

![Описание изображения](/images/image28.png)

Теперь фаервол не будет принимать входящих пакетов с tcp-флагами. Нулевые пакеты, по сути, разведывательные. они используются, чтобы выяснить настройки сервера и определить его слабые места.

* Далее нужно защитить сервер от разведывательных пакетов XMAS.

“sudo iptables -A INPUT -p tcp –tcp-flags ALL ALL -j DROP”

![Описание изображения](/images/image29.png)

По умолчанию все не сохраненные правила действуют до следующей перезагрузки сервера, сразу же после перезагрузки несохраненные правила будут потеряны. Самый простой способ – загрузить пакет iptables-persistent.

![Описание изображения](/images/image30.png)

Во время инсталляции пакет уточнит, нужно ли сохранить текущие правила для дальнейшей автоматической загрузки, если текущие правила были протестированы и соответствуют всем требованиям, их можно сохранить.

![Описание изображения](/images/image31.png)

Теперь сервер защищен от некоторых общих атак, которые ищут его уязвимости.

8. Со второй виртуальной машины проводим XMAS сканирование и зафиксируем результат:

![Описание изображения](/images/image32.png)

## Часть 2. WAF

1. Для более серьезной защиты загрузим готовый пакет правил OWASP на атакуемую машину:

![Описание изображения](/images/image33.png)

И устанавливаем их в модуль защиты:

![Описание изображения](/images/image34.png)

2. Установка ModSecurity включает в себя конфигурационный файл, который нужно переименовать:

![Описание изображения](/images/image35.png)

3. Стандартный конфигурационный файл настроен на DetectionOnly, то есть, фаервол только отслеживает логи, при этом ничего не блокируя. Чтобы изменить это поведение, отредактируем файл “modsecurity.conf” с помощью команды “sudo nano /etc/modsecurity/modsecurity.conf”. Находим в файле строку: «SecRuleEngine DetectionOnly» и изменяем её так: «SecRuleEngine On».

![Описание изображения](/images/image36.png)

4. Чтобы подгрузить эти готовые правила и правила OWASP, нужно, чтобы веб-сервер Apache читал указанные выше каталоги. Для этого командой “sudo nano /etc/apache2/mods-enabled/security2.conf” отредактируем файл security2.conf следующим образом:

![Описание изображения](/images/image37.png)

5. Чтобы новые правила вступили в исполнение, нужно перезапустить Apache:

![Описание изображения](/images/image38.png)

## Часть 3. Тестирование модуля защиты WAF.

1. Открываем для редактирования дефолтный файл конфигурации сайта 000-default.conf командой “sudo nano /etc/apache2/sites-available/000-default.conf”. Перед строкой “/VirtualHost” добавляем следующие 2 строки:

![Описание изображения](/images/image39.png)

Последняя добавленная строка - это правило, определяющее, что при попытке запроса с параметром «testparam» запрос будет отклонен с кодом 403.

2. На атакующей машине выполняем следующий запрос:

![Описание изображения](/images/image40.png)

Видим, что все правильно, запрос вернул результат «403 Forbidden»

3. Для закрепления результата выполняем сканирование утилитой nmap с опцией детектирования WAF. Выполните на атакующей машине с помощью команды “nmap –p 80 -sV --script=http-waf-fingerprint IP_атакуемой_машины”:

![Описание изображения](/images/image41.png)

4. На атакуемой машине в лог-файле /var/log/apache2/modsec_audit.log данное сканирование будет полностью зафиксировано. Проверим это командой “sudo nano /var/log/apache2/modsec_audit.log”:

![Описание изображения](/images/image42.png)
